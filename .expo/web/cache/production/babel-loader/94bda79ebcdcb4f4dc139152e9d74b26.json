{"ast":null,"code":"import{Extrapolate}from\"../derived/interpolate\";var internalInterpolate=function(){var _f=function _f(x,l,r,ll,rr,type){if(r-l===0)return ll;var progress=(x-l)/(r-l);var val=ll+progress*(rr-ll);var coef=rr>=ll?1:-1;type=type||Extrapolate.EXTEND;if(coef*val<coef*ll||coef*val>coef*rr){switch(type){case Extrapolate.IDENTITY:return x;case Extrapolate.CLAMP:if(coef*val<coef*ll){return ll;}return rr;case Extrapolate.EXTEND:default:return val;}}return val;};_f._closure={Extrapolate:{EXTEND:Extrapolate.EXTEND,IDENTITY:Extrapolate.IDENTITY,CLAMP:Extrapolate.CLAMP}};_f.asString=\"function internalInterpolate(x,l,r,ll,rr,type){const{Extrapolate}=jsThis._closure;{if(r-l===0)return ll;var progress=(x-l)/(r-l);var val=ll+progress*(rr-ll);var coef=rr>=ll?1:-1;type=type||Extrapolate.EXTEND;if(coef*val<coef*ll||coef*val>coef*rr){switch(type){case Extrapolate.IDENTITY:return x;case Extrapolate.CLAMP:if(coef*val<coef*ll){return ll;}return rr;case Extrapolate.EXTEND:default:return val;}}return val;}}\";_f.__workletHash=16794550962941;global.__reanimatedWorkletInit(_f);return _f;}();export var interpolate=function(){var _f=function _f(x,input,output,type){if(x&&x.__nodeID){throw new Error('Reanimated: interpolate from V1 has been renamed to interpolateNode.');}var length=input.length;var narrowedInput=[];if(x<input[0]){narrowedInput=[input[0],input[1],output[0],output[1]];}else if(x>input[length-1]){narrowedInput=[input[length-2],input[length-1],output[length-2],output[length-1]];}else{for(var i=1;i<length;++i){if(x<=input[i]){narrowedInput=[input[i-1],input[i],output[i-1],output[i]];break;}}}return internalInterpolate.apply({},[x].concat(narrowedInput).concat(type));};_f._closure={internalInterpolate:internalInterpolate};_f.asString=\"function interpolate(x,input,output,type){const{internalInterpolate}=jsThis._closure;{if(x&&x.__nodeID){throw new Error('Reanimated: interpolate from V1 has been renamed to interpolateNode.');}var length=input.length;var narrowedInput=[];if(x<input[0]){narrowedInput=[input[0],input[1],output[0],output[1]];}else if(x>input[length-1]){narrowedInput=[input[length-2],input[length-1],output[length-2],output[length-1]];}else{for(var i=1;i<length;++i){if(x<=input[i]){narrowedInput=[input[i-1],input[i],output[i-1],output[i]];break;}}}return internalInterpolate.apply({},[x].concat(narrowedInput).concat(type));}}\";_f.__workletHash=13867398897915;global.__reanimatedWorkletInit(_f);return _f;}();","map":{"version":3,"sources":["C:/Users/PC NOOB/Downloads/pokepoke/node_modules/react-native-reanimated/src/reanimated2/interpolation.js"],"names":["Extrapolate","internalInterpolate","x","l","r","ll","rr","type","progress","val","coef","EXTEND","IDENTITY","CLAMP","interpolate","input","output","__nodeID","Error","length","narrowedInput","i","apply","concat"],"mappings":"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","sourcesContent":["import { Extrapolate } from '../derived/interpolate';\n\nfunction internalInterpolate(x, l, r, ll, rr, type) {\n  'worklet';\n  if (r - l === 0) return ll;\n  const progress = (x - l) / (r - l);\n  const val = ll + progress * (rr - ll);\n  const coef = rr >= ll ? 1 : -1;\n\n  // TODO: support default values in worklets:\n  // e.g. function interplate(x, input, output, type = Extrapolate.CLAMP)\n  type = type || Extrapolate.EXTEND;\n\n  if (coef * val < coef * ll || coef * val > coef * rr) {\n    switch (type) {\n      case Extrapolate.IDENTITY:\n        return x;\n      case Extrapolate.CLAMP:\n        if (coef * val < coef * ll) {\n          return ll;\n        }\n        return rr;\n      case Extrapolate.EXTEND:\n      default:\n        return val;\n    }\n  }\n  return val;\n}\n\nexport function interpolate(x, input, output, type) {\n  'worklet';\n  if (x && x.__nodeID) {\n    throw new Error(\n      'Reanimated: interpolate from V1 has been renamed to interpolateNode.'\n    );\n  }\n  const length = input.length;\n  let narrowedInput = [];\n  if (x < input[0]) {\n    narrowedInput = [input[0], input[1], output[0], output[1]];\n  } else if (x > input[length - 1]) {\n    narrowedInput = [\n      input[length - 2],\n      input[length - 1],\n      output[length - 2],\n      output[length - 1],\n    ];\n  } else {\n    for (let i = 1; i < length; ++i) {\n      if (x <= input[i]) {\n        narrowedInput = [input[i - 1], input[i], output[i - 1], output[i]];\n        break;\n      }\n    }\n  }\n  return internalInterpolate.apply({}, [x].concat(narrowedInput).concat(type));\n}\n"]},"metadata":{},"sourceType":"module"}